---
title: FCSC 2021 - Write-Ups for the crypto challenges.
tags: write-ups, crypto
---

In this post, I’ll present my write-ups for all the challenges listed in the “Crypto” category, in the order I solved them during the competition.


The challenges are:

1. [Macaque – 50 points](#macaque-50-points)
2. [RSA Destroyer – 200 points](#rsa-destroyer-200-points)
3. [Lost curve – 200 points](#lost-curve-200-points)
4. [Hashy Parmentier – 200 points](#hashy-parmentier-200-points)
5. [Revaulting – 500 points](#revaulting-500-points)
6. [SmeaLog – 500 points](#smealog-500-points)
7. [Trappy Skippy – 500 points](#trappy-skippy-500-points)

<!--more-->

## MACAQUE – 50 POINTS
### DESCRIPTION

```
Retrouvez le flag avec l'accès à ce service distant.

nc challenges1.france-cybersecurity-challenge.fr 6000
```

The service’s source code was provided:
```python
#!/usr/bin/env python3
import os 
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from flag import flag
​
class Macaque():
    def __init__(self, k1, k2):
        self.k1 = k1
        self.k2 = k2
        self.bs = AES.block_size
        self.zero = b"\x00" * self.bs

    def tag(self, m):
        m = pad(m, self.bs)
        c1 = AES.new(self.k1, AES.MODE_CBC, iv = self.zero).encrypt(m)
        c2 = AES.new(self.k2, AES.MODE_CBC, iv = self.zero).encrypt(m)
        return c1[-self.bs:] + c2[-self.bs:]

    def verify(self, m, tag):
        return self.tag(m) == tag

def usage():
    print("Commands are:")
    print("|-> t: Authenticate a message")
    print("|-> v: Verify a couple (message, tag)")
    print("|-> q: Quit")

if __name__ == "__main__":

    S = set()
    singe = Macaque(os.urandom(16), os.urandom(16))

    while True:
        usage()
        cmd = input(">>> ")

        if not len(cmd):
            exit(1)

        if cmd not in ['t', 'v', 'q']:
            usage()
            continue

        if cmd == 'q':
            exit(0)

        if cmd == 't':
            if len(S) < 3:

                print("Message (hex):")
                message = bytes.fromhex(input(">>> "))
                if not len(message):
                    exit(1)

                tag = singe.tag(message)
                print(f"Tag (hex): {tag.hex()}")
                S.add(message)
            else:
                print("Error: you cannot use this command anymore.")

        elif cmd == 'v':
            print("Message (hex):")
            message = bytes.fromhex(input(">>> "))

            print("Tag (hex):")
            tag = bytes.fromhex(input(">>> "))

            check = singe.verify(message, tag)
            if check and message not in S:
                print(f"Congrats!! Here is the flag: {flag}")

            elif check and message in S:
                print("Valid!")

            else:
                print("Wrong tag. Try again.")​
```

### RESOLUTION

The aim of the challenge is to provide a message with a valid tag, that was not generated by the service. We have to perform a forgery attack.

By looking at how the Macaque class computes the tag, we see that it is composed of two parts:

1. The last block of the AES-CBC encryption of the message using an all zero IV and unknown key $k_1$;
2. The last block of the AES-CBC encryption of the message using an all zero IV and unknown key $k_2$.

Each part is actually an AES-CBC-MAC tag of the message with a different key.

We can provide 3 messages of any length to the service. CBC-MAC is known to be weak against variable-length messages. The [wikipedia](https://en.wikipedia.org/wiki/CBC-MAC#Security_with_fixed_and_variable-length_messages) article explains in detail why this is the case by showing how tag forgery can be achieved.

Basically if we know a pair of messages and tags $(m, t)$ and $(m', t')$, we can forge a message $m'' = m || m'_1 \oplus t || m'_2 || ... || m'_x$ (where $m'_x$ denotes the block $x$ of $m'$), whose tag will be $t'$.

We can apply the same technique on both parts of our tag individually to forge a new one.
